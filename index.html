<!--<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PWA リアルタイム・ボイスチェンジャー — 軽量グラニュラー低遅延版</title>
<meta name="theme-color" content="#1e293b">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo;background:#071021;color:#e6eef6;margin:0;display:flex;align-items:center;justify-content:center;height:100vh}
  .card{width:980px;max-width:95%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));padding:18px;border-radius:12px}
  h1{margin:0 0 8px;font-size:18px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  label{font-size:13px;color:#cfe6ff}
  input[type=range]{width:220px}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:white;font-weight:600;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .status{font-size:13px;color:#9fb7cf}
</style>
</head>
<body>
  <div class="card">
    <h1>リアルタイム・ボイスチェンジャー（軽量グラニュラー低遅延版）</h1>
    <p class="status">AudioWorklet が使えない場合は ScriptProcessor にフォールバックします。Safari / iOS にも対応。軽量化して遅延を約0.2秒以下に抑えています。</p>

    <div class="row">
      <button id="btnStart">Start</button>
      <button id="btnStop" class="ghost" disabled>Stop</button>
      <div style="margin-left:auto;">状態: <span id="state">停止中</span></div>
    </div>

    <div class="row">
      <label>ピッチ（半音） <span id="pval">0</span></label>
      <input type="range" id="pitch" min="-12" max="12" value="0">
      <label style="margin-left:18px">音量 <span id="vval">0.50</span></label>
      <input type="range" id="volume" min="0" max="1" step="0.01" value="0.5">
    </div>

    <div style="margin-top:12px;font-size:12px;color:#9fb7cf">
      遅延を最小化するため、短いバッファ（256〜512）と軽量ピッチ補間を使用しています。
    </div>
  </div>

<script>
const btnStart = document.getElementById('btnStart');
const btnStop = document.getElementById('btnStop');
const stateEl = document.getElementById('state');
const pitchEl = document.getElementById('pitch');
const pval = document.getElementById('pval');
const volumeEl = document.getElementById('volume');
const vval = document.getElementById('vval');

pval.textContent = pitchEl.value;
vval.textContent = volumeEl.value;

pitchEl.addEventListener('input', ()=> pval.textContent = pitchEl.value);
volumeEl.addEventListener('input', ()=> vval.textContent = volumeEl.value);

let audioContext = null;
let micStream = null;
let sourceNode = null;
let gainOut = null;
let workletNode = null;
let scriptNode = null;

async function startAudio() {
  if (audioContext) return;
  audioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
  await audioContext.resume();

  gainOut = audioContext.createGain();
  gainOut.gain.value = Number(volumeEl.value);
  gainOut.connect(audioContext.destination);

  try {
    // AudioWorklet軽量版
    const processorCode = `
    class LightPitchShift extends AudioWorkletProcessor {
      static get parameterDescriptors(){return[{name:'rate',defaultValue:1}]}
      constructor(){super();this.buf=new Float32Array(8192);this.wp=0;this.rp=0;}
      interp(idx){const i0=Math.floor(idx)&8191;const i1=(i0+1)&8191;const f=idx-Math.floor(idx);return this.buf[i0]*(1-f)+this.buf[i1]*f;}
      process(inputs,outputs,params){const i=inputs[0][0];const o=outputs[0][0];if(!i)return true;const rate=params.rate;const r=rate.length>1?rate[0]:rate[0];for(let n=0;n<i.length;n++){this.buf[this.wp]=i[n];this.wp=(this.wp+1)&8191;o[n]=this.interp(this.rp);this.rp+=r;if(this.rp>=8192)this.rp-=8192;}return true;}}
    registerProcessor('light-pitch',LightPitchShift);
    `;
    const blob=new Blob([processorCode],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(url);

    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioContext,'light-pitch',{parameterData:{rate:1}});
    sourceNode.connect(workletNode).connect(gainOut);

    const updateRate=()=>{
      const semis=Number(pitchEl.value);
      const rate=Math.pow(2,semis/12);
      workletNode.parameters.get('rate').setValueAtTime(rate,audioContext.currentTime);
    };
    pitchEl.addEventListener('input',updateRate);
    volumeEl.addEventListener('input',()=>{gainOut.gain.value=Number(volumeEl.value);});
    updateRate();

    stateEl.textContent='再生中 (AudioWorklet)';
    btnStart.disabled=true;btnStop.disabled=false;
  } catch(err){
    console.warn('AudioWorklet unavailable, fallback',err);
    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(micStream);
    const bufferSize=512; // 低遅延
    scriptNode = audioContext.createScriptProcessor(bufferSize,1,1);
    const buf=new Float32Array(8192);let wp=0;let rp=0;
    scriptNode.onaudioprocess=e=>{
      const i=e.inputBuffer.getChannelData(0);
      const o=e.outputBuffer.getChannelData(0);
      const semis=Number(pitchEl.value);
      const rate=Math.pow(2,semis/12);
      for(let n=0;n<i.length;n++){buf[wp]=i[n];wp=(wp+1)&8191;o[n]=buf[Math.floor(rp)&8191];rp+=rate;if(rp>=8192)rp-=8192;}
    };
    sourceNode.connect(scriptNode).connect(gainOut);
    pitchEl.addEventListener('input',()=>{});
    volumeEl.addEventListener('input',()=>{gainOut.gain.value=Number(volumeEl.value);});
    stateEl.textContent='再生中 (ScriptProcessor)';
    btnStart.disabled=true;btnStop.disabled=false;
  }
}

function stopAudio(){
  if(!audioContext)return;
  if(workletNode){workletNode.disconnect();workletNode=null;}
  if(scriptNode){scriptNode.disconnect();scriptNode=null;}
  if(sourceNode){sourceNode.disconnect();sourceNode=null;}
  if(micStream){micStream.getTracks().forEach(t=>t.stop());micStream=null;}
  audioContext.close();audioContext=null;
  stateEl.textContent='停止中';
  btnStart.disabled=false;btnStop.disabled=true;
}

btnStart.addEventListener('click',async()=>{
  try{await startAudio();}catch(e){alert('マイクが取得できませんでした: '+e.message);}
});
btnStop.addEventListener('click',()=>stopAudio());
</script>
</body>
</html>-->
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>リアルタイムボイスチェンジャー</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body {
      font-family: "Segoe UI", sans-serif;
      text-align: center;
      padding: 2em;
      background: linear-gradient(180deg, #d0e7ff, #f8faff);
      color: #333;
    }
    button, input[type="range"], select {
      margin: 1em;
      padding: 0.5em 1em;
      font-size: 1.1em;
      border-radius: 10px;
      border: 1px solid #ccc;
    }
    label { display: block; margin-top: 1em; }
  </style>
</head>
<body>
  <h1>🎧 リアルタイムボイスチェンジャー</h1>

  <button id="startBtn">Start</button>

  <label>音量:
    <input id="volume" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>

  <label>モード選択:
    <select id="mode">
      <option value="normal">ノーマル</option>
      <option value="female">女性風（高ピッチ・フォルマント補正）</option>
      <option value="male">男性風（低ピッチ・フォルマント補正）</option>
      <option value="chipmunk">チップマンク風</option>
      <option value="deep">低音強化</option>
    </select>
  </label>

  <script>
    let audioCtx, source, gainNode, pitchShiftNode;
    let modeSelect = document.getElementById('mode');
    let volumeSlider = document.getElementById('volume');

    async function start() {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });

      source = audioCtx.createMediaStreamSource(stream);
      gainNode = audioCtx.createGain();
      gainNode.gain.value = volumeSlider.value;

      // --- ピッチシフト用ノード (ScriptProcessorNode で軽量処理) ---
      const bufferSize = 1024;
      const scriptNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
      const delay = new Float32Array(bufferSize).fill(0);
      let delayIndex = 0;
      let pitchFactor = 1.0;

      scriptNode.onaudioprocess = (e) => {
        const input = e.inputBuffer.getChannelData(0);
        const output = e.outputBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          delay[delayIndex] = input[i];
          const readIndex = (delayIndex - bufferSize / pitchFactor + bufferSize) % bufferSize;
          const index1 = Math.floor(readIndex);
          const index2 = (index1 + 1) % bufferSize;
          const frac = readIndex - index1;
          output[i] = delay[index1] * (1 - frac) + delay[index2] * frac;
          delayIndex = (delayIndex + 1) % bufferSize;
        }
      };

      // --- モード別ピッチ設定 ---
      function setMode() {
        switch (modeSelect.value) {
          case "female":
            pitchFactor = 1.5; // 約+7半音
            break;
          case "male":
            pitchFactor = 0.7; // 約-5半音
            break;
          case "chipmunk":
            pitchFactor = 2.0;
            break;
          case "deep":
            pitchFactor = 0.5;
            break;
          default:
            pitchFactor = 1.0;
        }
      }
      modeSelect.onchange = setMode;
      setMode();

      volumeSlider.oninput = () => {
        gainNode.gain.value = volumeSlider.value;
      };

      source.connect(scriptNode);
      scriptNode.connect(gainNode);
      gainNode.connect(audioCtx.destination);
    }

    document.getElementById("startBtn").onclick = () => {
      start().catch(err => alert("マイク取得エラー: " + err.message));
    };
  </script>
</body>
</html>
