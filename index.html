<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PWA リアルタイム・ボイスチェンジャー — 軽量グラニュラー低遅延版</title>
<meta name="theme-color" content="#1e293b">
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo;background:#071021;color:#e6eef6;margin:0;display:flex;align-items:center;justify-content:center;height:100vh}
  .card{width:980px;max-width:95%;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));padding:18px;border-radius:12px}
  h1{margin:0 0 8px;font-size:18px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  label{font-size:13px;color:#cfe6ff}
  input[type=range]{width:220px}
  button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:white;font-weight:600;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
  .status{font-size:13px;color:#9fb7cf}
</style>
</head>
<body>
  <div class="card">
    <h1>リアルタイム・ボイスチェンジャー（軽量グラニュラー低遅延版）</h1>
    <p class="status">AudioWorklet が使えない場合は ScriptProcessor にフォールバックします。Safari / iOS にも対応。軽量化して遅延を約0.2秒以下に抑えています。</p>

    <div class="row">
      <button id="btnStart">Start</button>
      <button id="btnStop" class="ghost" disabled>Stop</button>
      <div style="margin-left:auto;">状態: <span id="state">停止中</span></div>
    </div>

    <div class="row">
      <label>ピッチ（半音） <span id="pval">0</span></label>
      <input type="range" id="pitch" min="-12" max="12" value="0">
      <label style="margin-left:18px">音量 <span id="vval">0.50</span></label>
      <input type="range" id="volume" min="0" max="1" step="0.01" value="0.5">
    </div>

    <div style="margin-top:12px;font-size:12px;color:#9fb7cf">
      遅延を最小化するため、短いバッファ（256〜512）と軽量ピッチ補間を使用しています。
    </div>
  </div>

<script>
const btnStart = document.getElementById('btnStart');
const btnStop = document.getElementById('btnStop');
const stateEl = document.getElementById('state');
const pitchEl = document.getElementById('pitch');
const pval = document.getElementById('pval');
const volumeEl = document.getElementById('volume');
const vval = document.getElementById('vval');

pval.textContent = pitchEl.value;
vval.textContent = volumeEl.value;

pitchEl.addEventListener('input', ()=> pval.textContent = pitchEl.value);
volumeEl.addEventListener('input', ()=> vval.textContent = volumeEl.value);

let audioContext = null;
let micStream = null;
let sourceNode = null;
let gainOut = null;
let workletNode = null;
let scriptNode = null;
let pitchShift = 1.4;  // ピッチを1.0→1.4倍で女性っぽく
let formantShift = 1.3; // フォルマント（声質）補正倍率

async function startAudio() {
/*  if (audioContext) return;
  audioContext = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: "interactive" });
  await audioContext.resume();

  gainOut = audioContext.createGain();
  gainOut.gain.value = Number(volumeEl.value);
  gainOut.connect(audioContext.destination);

  try {
    // AudioWorklet軽量版
    const processorCode = `
    class LightPitchShift extends AudioWorkletProcessor {
      static get parameterDescriptors(){return[{name:'rate',defaultValue:1}]}
      constructor(){super();this.buf=new Float32Array(8192);this.wp=0;this.rp=0;}
      interp(idx){const i0=Math.floor(idx)&8191;const i1=(i0+1)&8191;const f=idx-Math.floor(idx);return this.buf[i0]*(1-f)+this.buf[i1]*f;}
      process(inputs,outputs,params){const i=inputs[0][0];const o=outputs[0][0];if(!i)return true;const rate=params.rate;const r=rate.length>1?rate[0]:rate[0];for(let n=0;n<i.length;n++){this.buf[this.wp]=i[n];this.wp=(this.wp+1)&8191;o[n]=this.interp(this.rp);this.rp+=r;if(this.rp>=8192)this.rp-=8192;}return true;}}
    registerProcessor('light-pitch',LightPitchShift);
    `;
    const blob=new Blob([processorCode],{type:'application/javascript'});
    const url=URL.createObjectURL(blob);
    await audioContext.audioWorklet.addModule(url);

    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(micStream);
    workletNode = new AudioWorkletNode(audioContext,'light-pitch',{parameterData:{rate:1}});
    sourceNode.connect(workletNode).connect(gainOut);

    const updateRate=()=>{
      const semis=Number(pitchEl.value);
      const rate=Math.pow(2,semis/12);
      workletNode.parameters.get('rate').setValueAtTime(rate,audioContext.currentTime);
    };
    pitchEl.addEventListener('input',updateRate);
    volumeEl.addEventListener('input',()=>{gainOut.gain.value=Number(volumeEl.value);});
    updateRate();

    stateEl.textContent='再生中 (AudioWorklet)';
    btnStart.disabled=true;btnStop.disabled=false;
  } catch(err){
    console.warn('AudioWorklet unavailable, fallback',err);
    micStream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(micStream);
    const bufferSize=512; // 低遅延
    scriptNode = audioContext.createScriptProcessor(bufferSize,1,1);
    const buf=new Float32Array(8192);let wp=0;let rp=0;
    scriptNode.onaudioprocess=e=>{
      const i=e.inputBuffer.getChannelData(0);
      const o=e.outputBuffer.getChannelData(0);
      const semis=Number(pitchEl.value);
      const rate=Math.pow(2,semis/12);
      for(let n=0;n<i.length;n++){buf[wp]=i[n];wp=(wp+1)&8191;o[n]=buf[Math.floor(rp)&8191];rp+=rate;if(rp>=8192)rp-=8192;}
    };
    sourceNode.connect(scriptNode).connect(gainOut);
    pitchEl.addEventListener('input',()=>{});
    volumeEl.addEventListener('input',()=>{gainOut.gain.value=Number(volumeEl.value);});
    stateEl.textContent='再生中 (ScriptProcessor)';
    btnStart.disabled=true;btnStop.disabled=false;
  }
}*/



//async function startVoiceChanger() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const source = audioCtx.createMediaStreamSource(stream);

  // ピッチシフト（再生速度変更）
  const pitchNode = audioCtx.createBufferSource();
  const processor = audioCtx.createScriptProcessor(1024, 1, 1);
  
  // 周波数補正（フォルマント風EQ）
  const biquad = audioCtx.createBiquadFilter();
  biquad.type = "peaking";
  biquad.frequency.value = 2000 * formantShift; // 中高域を持ち上げ
  biquad.gain.value = 6; // dB
  
  // 音量コントロール
  const gainNode = audioCtx.createGain();
  gainNode.gain.value = 0.5;

  // 出力接続
  source.connect(biquad);
  biquad.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  console.log("Voice changer started!");
}


function stopAudio(){
  if(!audioContext)return;
  if(workletNode){workletNode.disconnect();workletNode=null;}
  if(scriptNode){scriptNode.disconnect();scriptNode=null;}
  if(sourceNode){sourceNode.disconnect();sourceNode=null;}
  if(micStream){micStream.getTracks().forEach(t=>t.stop());micStream=null;}
  audioContext.close();audioContext=null;
  stateEl.textContent='停止中';
  btnStart.disabled=false;btnStop.disabled=true;
}

btnStart.addEventListener('click',async()=>{
  try{await startAudio();}catch(e){alert('マイクが取得できませんでした: '+e.message);}
});
btnStop.addEventListener('click',()=>stopAudio());
</script>
</body>
</html>
